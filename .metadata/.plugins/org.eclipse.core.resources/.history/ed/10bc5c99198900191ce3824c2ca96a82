package com.core.x.service;

import java.text.DateFormatSymbols;
import java.text.ParseException;
import java.text.SimpleDateFormat;
import java.time.Instant;
import java.time.LocalDate;
import java.time.temporal.ChronoUnit;
import java.util.ArrayList;
import java.util.Calendar;
import java.util.Date;
import java.util.List;
import java.util.Optional;
import java.util.UUID;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.boot.configurationprocessor.json.JSONException;
import org.springframework.boot.configurationprocessor.json.JSONObject;
import org.springframework.data.domain.Page;
import org.springframework.data.domain.Pageable;
import org.springframework.data.mongodb.core.MongoOperations;
import org.springframework.data.mongodb.core.query.Criteria;
import org.springframework.data.mongodb.core.query.Query;
import org.springframework.stereotype.Service;

import com.core.x.domain.Ticket;
import com.core.x.repository.TicketRepository;


@Service
public class TicketService {

	private final TicketRepository ticketRepository;

	@Autowired
	MongoOperations mongoOperations;

	public TicketService(TicketRepository ticketRepository) {
		this.ticketRepository = ticketRepository;
	}
	
	
	public Ticket createTicket(Ticket ticket) {
		return ticketRepository.save(ticket);
	}
	
	public Page<Ticket> getAllCreatedTickets(Pageable pageable) {
        return ticketRepository.findAll(pageable);
    }
	
	public List<Ticket> getopenTicket() {
		Criteria criteria1 = Criteria.where("created_at").gte(LocalDate.now().minusDays(7)).lte(LocalDate.now());
        Query query = new Query(criteria1);
        List<Ticket> ticketList = mongoOperations.find(query, Ticket.class);
        List<Ticket> tck=new ArrayList<>();
        for(Ticket ticket:ticketList) {
        	if(ticket.getTicketStatus().equals("opened") || ticket.getTicketStatus().equals("unsolved")|| ticket.getTicketStatus().equals("solved")) {
        		tck.add(ticket);
        	}
        }
        return tck;
     }
	
	
	public List<Ticket> getAllTicketsWithStatus(String status) {
		List<Ticket>tickets=ticketRepository.findByTicketStatus(status);
		List<Ticket> ticketStatus=new ArrayList<>();
		ticketStatus.clear();
		int count=0;
       		for(Ticket tk:tickets) {
        	if(status.equals(tk.getTicketStatus())) {
        		count++;
        		ticketStatus.add(tk);	
        	}	
       		}
       		System.out.println(count);
			return ticketStatus; 	
    }
	

	public List<Ticket> getUnrepliedUnsolvedTickets(String status,String response) { 
        List<Ticket> list=ticketRepository.findByTicketStatus(status);
        List<Ticket> ticket=new ArrayList<>();
        long sum=0;
        for(Ticket tk:list) {
        	if(status.equals(tk.getTicketStatus()) && response.equals(tk.getTicketResponse())) {
        		ticket.add(tk);
        	}
        }
    	return ticket;

    }
	
	public List<Ticket> getAllNewAndOpenedTicket() {
		Criteria criteria1 = Criteria.where("created_at").gt(LocalDate.now());
		System.out.println(LocalDate.now());
        Query query = new Query(criteria1);
        List<Ticket> ticket = mongoOperations.find(query, Ticket.class);
        System.out.println(ticket);
        List<Ticket> tr=new ArrayList<>();
        tr.clear();
        for(Ticket tk:ticket) {
        	if(tk.getTicketStatus().equalsIgnoreCase("unsolved")||tk.getTicketStatus().equalsIgnoreCase("opened")) {
        	  tr.add(tk);	
        	}
        }
        return tr;
	
    }
	
	
	public Optional<Ticket> updateTicket(Ticket ticket,UUID id) {
		Optional<Ticket> tk=ticketRepository.findById(id);
		//tk.get().setCreatedAt(createdAt);
		ticketRepository.save(tk.get());
		return tk;
	}
	
	
	public String getAllunsloveticketsByStatus(String ticketStatus) throws JSONException {
		List<Ticket> tk=ticketRepository.findByTicketStatus(ticketStatus);
		 List<Ticket> newList=new ArrayList<>();
	        List<Ticket> openList=new ArrayList<>();
	        List<Ticket> pendingList=new ArrayList<>();
	        List<Ticket> holdList=new ArrayList<>();
	        JSONObject json=new JSONObject();
			for(Ticket t:tk) {
				if(t.getStatus().equalsIgnoreCase("New")) {
					newList.add(t);
				}
				else if(t.getStatus().equalsIgnoreCase("open")) {
					openList.add(t);
				}
				else if(t.getStatus().equalsIgnoreCase("pending")) {
					pendingList.add(t);
				}
				else {
					holdList.add(t);
				}
			}
			
			json.put("new",newList.size());
	        json.put("open",openList.size());
	        json.put("pending",pendingList.size());   
	        json.put("hold",holdList.size());
			
			return json.toString();
		}
    
	
	public String getAllCreatedTicketsLastSevendays() throws JSONException {
		Criteria criteria1 = Criteria.where("created_at").gt(LocalDate.now().minusDays(7)).lt(LocalDate.now());
		System.out.println(Criteria.where("created_at").gte(LocalDate.now().minusDays(6)).lt(LocalDate.now().plusDays(1)));
		System.out.println(LocalDate.now()+"/n"+LocalDate.now().minusDays(7));
        Query query = new Query(criteria1); 
        List<Ticket> as = mongoOperations.find(query, Ticket.class);
        System.out.println(as);
        JSONObject json=new JSONObject();
        List<Ticket> newtkList=new ArrayList<>();
        List<Ticket> opentkList=new ArrayList<>();
       for(Ticket tkt:as) {
    	if(tkt.getStatus().equalsIgnoreCase("new"))  {
    		newtkList.add(tkt);
       }
    	else if(tkt.getStatus().equalsIgnoreCase("open")) {
    		opentkList.add(tkt);
    	}
       }
       json.put("totalTickets", as.size());
       json.put("newTicket", newtkList.size());
       json.put("openTicket", opentkList.size());
        return json.toString();
	
    }
	
	
	public Long timeSinceUpdate(String status) {
		 long timeSinceUpdateDays = 0;
		 List<Ticket> tklist=ticketRepository.findByTicketStatus(status);
		 for(Ticket tk:tklist) {
				 long  noOfDays = ChronoUnit.DAYS.between(tk.getUpdatedAt(), Instant.now());
				 timeSinceUpdateDays=timeSinceUpdateDays+noOfDays;
			 }
		
		 System.out.println(timeSinceUpdateDays);
		  return timeSinceUpdateDays;
    }
	
	
	public Long unassignTicketAge(String status,String response) {
		 long unassignedTicketAge = 0;
		 List<Ticket> tklist=ticketRepository.findByTicketStatus(status);
		 for(Ticket tk:tklist) {
			 if(tk.getTicketResponse().equals(response)&&tk.getTicketResponse()!=null) {
				 long  noOfDays = ChronoUnit.DAYS.between(Instant.now(),tk.getDueAt());
				 unassignedTicketAge=unassignedTicketAge+noOfDays;
			 }
		 }
		 System.out.println(unassignedTicketAge);
		  return unassignedTicketAge;
   }
	
		public String ticketByFullRsolutionTime(String ticketStatus) throws ParseException, JSONException {
		List<Ticket> tlist=ticketRepository.findByTicketStatus(ticketStatus);
        List<Ticket> hoursList=new ArrayList<>();
        List<Ticket> dayList=new ArrayList<>();
        List<Ticket> weekList=new ArrayList<>();
        List<Ticket> afteweekList=new ArrayList<>();
        JSONObject json=new JSONObject();
        for(Ticket t:tlist) {
        	Instant date1=t.getCreatedAt();
		Instant date2=t.getUpdatedAt();
		long seconds=date2.getEpochSecond()-date1.getEpochSecond();
		long hours=seconds/3600;
	 long days=seconds/86400;
        if(hours<=8) {
        	hoursList.add(t);	
        }
        else if (hours > 8 && hours <= 24) {
        	dayList.add(t);
		}
        else if (days >= 1 && days <= 7) {
        	weekList.add(t);
		}
	
		else {
			afteweekList.add(t);
		}

        }
        json.put("0-8hrs",hoursList.size());
        json.put("8-24hrs",dayList.size());
        json.put("1-7days",weekList.size());   
        json.put(">7days",afteweekList.size());
        
        return json.toString();
	}
		
		
		
	public String CreateTicketsDayOfWeek(String ticketStatus) throws JSONException, ParseException {
		Criteria criteria1 = Criteria.where("created_at").gt(LocalDate.now().minusDays(7)).lt(LocalDate.now());
		System.out.println(LocalDate.now()+""+LocalDate.now().minusDays(7));
        Query query = new Query();
        query.addCriteria(criteria1).addCriteria(new Criteria().andOperator(Criteria.where("ticket_status").is(ticketStatus)));
        List<Ticket> tlist = mongoOperations.find(query, Ticket.class);
        System.out.println(tlist);
		List<Ticket> monList=new ArrayList<>();
        List<Ticket> tusList=new ArrayList<>();
        List<Ticket> wedList=new ArrayList<>();
        List<Ticket> thuList=new ArrayList<>();
        List<Ticket> friList=new ArrayList<>();
        List<Ticket> satList=new ArrayList<>();
        List<Ticket> sunList=new ArrayList<>();
        JSONObject json=new JSONObject();
    	for(Ticket t:tlist) {
    		Date date = Date.from(t.getCreatedAt());
    		SimpleDateFormat simpleDateformat = new SimpleDateFormat("EEEE"); // the day of the week spelled out completely
 	        String  s1=simpleDateformat.format(date);  
    		   System.out.println(date+""+s1);
	      
			if(s1.equals("Monday")) {
				monList.add(t);
			}
			else if(s1.equals("Tuesday")) {
				tusList.add(t);
			}
			else if(s1.equals("Wednesday")) {
				wedList.add(t);
			}
			else if(s1.equals("Thursday")) {
				thuList.add(t);
			}
			else if(s1.equals("Friday")) {
				friList.add(t);
			}
			else if(s1.equals("Saturday")) {
				satList.add(t);
			}
			else {
				sunList.add(t);
			}
    	}
			
			json.put("Monday", monList.size());
			json.put("Tuesday", tusList.size());
			json.put("Wednesday", wedList.size());
			json.put("Thursday", thuList.size());
			json.put("Friday", friList.size());
			json.put("Saturday", satList.size());
			json.put("Sunday", sunList.size());
    	
			return json.toString();

		}
	
}
